# 익스펜더 화살표 위치 변경 기획안

## 1. 문제 정의

### 1.1 현상
- **현재 상태**: Expander의 화살표 아이콘이 제목 텍스트의 **오른쪽 끝**에 위치
- **요구사항**: Expander의 화살표 아이콘이 제목 텍스트의 **앞(왼쪽)**에 위치해야 함

### 1.2 영향 범위
- 모든 페이지의 `st.expander` 컴포넌트
- 사이드바의 "상세 선택" expander
- 메인 콘텐츠의 모든 expander

## 2. 다각적 분석

### 2.1 UX/UI 관점 분석

#### 현재 위치 (오른쪽 끝)의 장단점
**장점:**
- Streamlit 기본 동작과 일치
- 많은 UI 프레임워크의 표준 패턴 (Material Design, Bootstrap 등)
- 제목 텍스트가 왼쪽 정렬되어 읽기 쉬움

**단점:**
- 한국어 사용자에게는 왼쪽에 화살표가 더 직관적일 수 있음
- 제목이 길 경우 화살표가 멀리 떨어져 보임

#### 요구 위치 (왼쪽 앞)의 장단점
**장점:**
- 제목과 화살표가 가까워서 시각적 연결성 향상
- 한국어 사용자에게 더 친숙한 패턴
- 제목이 길어도 화살표가 항상 앞에 있어 일관성 유지

**단점:**
- Streamlit 기본 동작과 다름 (커스터마이징 필요)
- 다른 Streamlit 앱과의 일관성 저하

### 2.2 기술적 관점 분석

#### Streamlit Expander 구조 (추정)
```
[data-testid="stExpander"]
  └─ button (또는 div)
      ├─ 제목 텍스트
      └─ [data-testid="stIconMaterial"] (화살표 아이콘)
```

#### 구현 방법 비교

**방법 1: CSS Flexbox로 순서 변경**
- `flex-direction: row-reverse` 사용
- 장점: 간단, CSS만으로 해결
- 단점: 다른 요소들의 순서도 바뀔 수 있음

**방법 2: CSS Order 속성 사용**
- `order: -1`로 아이콘을 앞으로 이동
- 장점: 정확한 제어 가능
- 단점: Flexbox 컨테이너여야 함

**방법 3: JavaScript로 DOM 순서 변경**
- 아이콘 요소를 제목 앞으로 이동
- 장점: 완전한 제어, 모든 경우에 작동
- 단점: JavaScript 의존, 성능 고려 필요

**방법 4: CSS ::before로 아이콘 재생성**
- 원본 아이콘 숨기고 ::before로 앞에 생성
- 장점: 원본 구조 유지
- 단점: 복잡, 아이콘 상태 관리 어려움

### 2.3 접근성 관점 분석

- 화살표 위치가 접근성에 미치는 영향은 미미
- 스크린 리더는 순서대로 읽으므로 위치보다는 의미가 중요
- 키보드 네비게이션에는 영향 없음

### 2.4 유지보수 관점 분석

- Streamlit 업데이트 시 구조 변경 가능성
- CSS 선택자의 안정성
- JavaScript 의존성 관리

## 3. 해결 방안

### 방안 1: CSS Flexbox Order 사용 (권장)

**구현:**
```css
[data-testid="stExpander"] button {
    display: flex !important;
    flex-direction: row !important;
}

[data-testid="stExpander"] [data-testid="stIconMaterial"] {
    order: -1 !important;
    margin-right: 0.5rem !important;
}
```

**장점:**
- CSS만으로 해결 (JavaScript 불필요)
- 성능 우수
- 유지보수 용이

**단점:**
- Flexbox가 아닌 경우 작동 안 함
- Streamlit 구조 변경 시 영향 받을 수 있음

### 방안 2: JavaScript로 DOM 순서 변경

**구현:**
```javascript
document.querySelectorAll('[data-testid="stExpander"]').forEach(expander => {
    const button = expander.querySelector('button');
    const icon = button.querySelector('[data-testid="stIconMaterial"]');
    const text = button.childNodes[0]; // 텍스트 노드
    
    if (icon && text) {
        button.insertBefore(icon, text);
    }
});
```

**장점:**
- 모든 경우에 작동
- 완전한 제어 가능

**단점:**
- JavaScript 의존
- DOM 변경 감지 필요
- 성능 고려 필요

### 방안 3: CSS ::before로 아이콘 재생성

**구현:**
```css
[data-testid="stExpander"] button::before {
    content: 'keyboard_arrow_right';
    font-family: 'Material Icons';
    /* 스타일 */
}

[data-testid="stExpander"] [data-testid="stIconMaterial"] {
    display: none;
}
```

**장점:**
- 원본 구조 유지
- CSS만으로 해결

**단점:**
- 아이콘 상태(열림/닫힘) 관리 복잡
- 동적 상태 변경 어려움

### 방안 4: 하이브리드 (CSS + JavaScript)

**구현:**
- CSS로 기본 위치 조정 시도
- JavaScript로 실패 시 DOM 조작

**장점:**
- 최대 호환성
- 안정성 높음

**단점:**
- 복잡도 증가

## 4. 권장 방안: 하이브리드 접근

### Phase 1: CSS Flexbox Order 시도
- 가장 간단하고 성능이 좋은 방법
- 대부분의 경우 작동할 것으로 예상

### Phase 2: JavaScript 백업
- CSS가 작동하지 않는 경우를 대비
- MutationObserver로 새로 추가된 expander에도 적용

## 5. 구현 세부사항

### 5.1 CSS 구현
1. Expander 버튼을 flexbox로 설정
2. 아이콘에 `order: -1` 적용하여 앞으로 이동
3. 아이콘과 텍스트 사이 간격 조정 (`margin-right`)

### 5.2 JavaScript 구현
1. 모든 expander 버튼 찾기
2. 아이콘과 텍스트 노드 순서 확인
3. 필요시 DOM 순서 변경
4. MutationObserver로 새 expander 감지

### 5.3 상태 관리
- Expander 열림/닫힘 상태에 따라 아이콘 방향 변경
- `keyboard_arrow_right` ↔ `keyboard_arrow_down`

## 6. 예상 부작용 및 대응

### 부작용 1: 다른 버튼에 영향
- **대응**: 선택자를 `[data-testid="stExpander"]`로 제한

### 부작용 2: Streamlit 업데이트 시 호환성
- **대응**: 표준 선택자 사용, 테스트 강화

### 부작용 3: 성능 저하
- **대응**: CSS 우선, JavaScript는 최소화

## 7. 테스트 계획

1. 모든 페이지의 expander 확인
2. Expander 열림/닫힘 상태 확인
3. 다양한 제목 길이 테스트
4. 사이드바와 메인 콘텐츠 모두 확인
5. 브라우저 호환성 테스트

## 8. 우선순위

1. **최우선**: CSS Flexbox Order 방법 구현
2. **백업**: JavaScript DOM 조작 방법 준비
3. **검증**: 모든 expander에서 테스트
