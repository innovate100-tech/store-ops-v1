# 📊 페이지 연관성 및 데이터 흐름 정리

## 🔗 연관 페이지 그룹별 정리

---

## 1️⃣ **마스터 데이터 체인** (초기 설정, 변경 시 업데이트)

### 데이터 흐름
```
재료 등록 (🥬)
    ↓ [재료명, 단위, 단가, 발주단위, 변환비율]
메뉴 등록 (🍽️)
    ↓ [메뉴명, 판매가]
레시피 등록 (📝)
    ↓ [메뉴명 + 재료명 + 사용량] 매핑
원가 파악 (💰)
    ↓ [메뉴별 원가, 원가율 계산]
```

### 연관 페이지 상세

#### **재료 등록** → **레시피 등록** → **원가 파악**
- **재료 등록**에서 입력한 재료 단가가 **레시피 등록**에서 사용됨
- **레시피 등록**에서 메뉴별 재료 사용량이 **원가 파악**에서 원가 계산에 사용됨
- **원가 파악**은 `menu_master` + `recipes` + `ingredient_master`를 조합하여 계산

**숫자 연동:**
- 재료 단가 × 레시피 사용량 = 메뉴 원가
- 메뉴 원가 ÷ 판매가 × 100 = 원가율

---

## 2️⃣ **일일 운영 데이터 체인** (매일 사용)

### 데이터 흐름
```
점장 마감 (📋) 또는 매출 등록 (💰)
    ↓ [날짜별 매출, 방문자수]
    ↓ [메뉴별 판매수량] → daily_sales_items
판매량 등록 (📦) [선택적]
    ↓ [추가 판매량 데이터]
재료 사용량 집계 (📈)
    ↓ [daily_sales_items × recipes] 계산
    ↓ [재료별 총 사용량, 총 사용단가]
발주 관리 (🛒)
    ↓ [재료 사용량 + 현재고 + 안전재고]
    ↓ [발주 추천, 발주 분석]
```

### 연관 페이지 상세

#### **점장 마감/매출 등록** → **판매량 등록** → **재료 사용량 집계** → **발주 관리**

**A. 점장 마감 (📋) 또는 매출 등록 (💰)**
- 일일 매출, 방문자수, 메뉴별 판매수량 입력
- `daily_close` 테이블 또는 `sales` 테이블에 저장
- `daily_sales_items` 테이블에 메뉴별 판매수량 저장

**B. 판매량 등록 (📦)** [선택적]
- 추가로 판매량 데이터 입력 가능
- `daily_sales_items` 테이블에 추가

**C. 재료 사용량 집계 (📈)**
- `daily_sales_items` × `recipes` = 재료별 사용량 계산
- 예: "김치찌개 10개 판매" × "김치찌개 레시피(돼지고기 200g)" = "돼지고기 2,000g 사용"

**숫자 연동:**
- 메뉴 판매수량 × 레시피 사용량 = 재료 사용량
- 재료 사용량 × 재료 단가 = 재료 사용 단가

**D. 발주 관리 (🛒)**
- 재료 사용량 집계 결과를 기반으로 발주 추천
- 현재고 - 사용량 < 안전재고 → 발주 필요

**숫자 연동:**
- 현재고 - 예상 사용량 < 안전재고 → 발주 수량 계산

---

## 3️⃣ **분석 및 대시보드 체인** (주기적 조회)

### 데이터 흐름
```
매출 관리 (📊)
    ↓ [sales 데이터 분석]
판매 관리 (📦)
    ↓ [daily_sales_items + menu_master 분석]
    ↓ [ABC 분석, 메뉴별 성과]
통합 대시보드 (📊)
    ↓ [모든 데이터 통합 분석]
    ↓ [손익분기점, 매출 추이, 메뉴 성과]
```

### 연관 페이지 상세

#### **매출 관리** + **판매 관리** → **통합 대시보드**

**A. 매출 관리 (📊)**
- `sales` 테이블 기반 매출 분석
- 날짜별, 기간별 매출 추이
- 카드/현금 매출 분리 분석

**B. 판매 관리 (📦)**
- `daily_sales_items` + `menu_master` 기반 판매 분석
- 메뉴별 판매량, 매출, 공헌이익
- ABC 분석 (A등급: 매출 비중 높음, C등급: 낮음)

**C. 통합 대시보드 (📊)**
- 매출 관리 + 판매 관리 데이터 통합
- 손익분기점 계산 (고정비 ÷ (1 - 변동비율))
- 메뉴별 성과 대시보드

**숫자 연동:**
- 매출 = 판매수량 × 판매가
- 공헌이익 = 매출 - 원가
- 손익분기점 매출 = 고정비 ÷ (1 - 변동비율)

---

## 4️⃣ **재무 계획 및 정산 체인** (월 1-2회)

### 데이터 흐름
```
목표 비용구조 (💳)
    ↓ [월별 목표 비용 항목 설정]
    ↓ [임차료, 인건비, 재료비, 공과금, 부가세&카드수수료]
목표 매출구조 (📈)
    ↓ [목표 비용구조 기반]
    ↓ [손익분기점 매출, 목표 매출 계산]
실제정산 (🧾)
    ↓ [목표 비용구조 + 목표 매출구조]
    ↓ [실제 매출 (sales) + 실제 비용 입력]
    ↓ [목표 vs 실제 비교 분석]
```

### 연관 페이지 상세

#### **목표 비용구조** → **목표 매출구조** → **실제정산**

**A. 목표 비용구조 (💳)**
- 월별 목표 비용 항목 설정
- 고정비: 임차료, 인건비, 공과금 (금액 직접 입력)
- 변동비: 재료비, 부가세&카드수수료 (매출 대비 비율 입력)
- `expense_structure` 테이블에 저장

**B. 목표 매출구조 (📈)**
- **목표 비용구조**에서 고정비, 변동비율 가져옴
- 손익분기점 매출 계산: 고정비 ÷ (1 - 변동비율)
- 목표 매출 설정 (`targets` 테이블)
- 실제 판매 데이터(`daily_sales_items`) 기반 매출 구조 분석

**숫자 연동:**
- 손익분기점 매출 = 고정비 ÷ (1 - 변동비율)
- 목표 매출 = 손익분기점 매출 × 목표 마진율

**C. 실제정산 (🧾)**
- **목표 비용구조**의 템플릿을 기반으로 실제 비용 입력
- **목표 매출구조**의 목표 매출과 실제 매출(`sales`) 비교
- 목표 vs 실제 차이 분석

**숫자 연동:**
- 목표 대비 달성률 = (실제 매출 ÷ 목표 매출) × 100
- 목표 대비 비용 차이 = 실제 비용 - 목표 비용
- 순이익 = 실제 매출 - 실제 비용

---

## 5️⃣ **발주 관리 체인** (재고 관리)

### 데이터 흐름
```
재료 사용량 집계 (📈)
    ↓ [기간별 재료 사용량]
발주 관리 (🛒)
    ↓ [재료 사용량 + 현재고 + 안전재고]
    ↓ [발주 추천 수량 계산]
    ↓ [발주 이력 관리]
```

### 연관 페이지 상세

#### **재료 사용량 집계** → **발주 관리**

**A. 재료 사용량 집계 (📈)**
- 기간별 재료 사용량 계산
- `daily_sales_items` × `recipes` = 재료별 총 사용량

**B. 발주 관리 (🛒)**
- 재료 사용량 기반 발주 추천
- 현재고 - 예상 사용량 < 안전재고 → 발주 필요
- 발주 수량 = (안전재고 + 예상 사용량) - 현재고

**숫자 연동:**
- 발주 필요 여부: 현재고 - 예상 사용량 < 안전재고
- 발주 수량 = 안전재고 + 예상 사용량 - 현재고

---

## 6️⃣ **리포트 생성 체인** (주간/월간)

### 데이터 흐름
```
주간 리포트 (📄)
    ↓ [모든 데이터 통합]
    ↓ [매출, 판매, 재료 사용량, 원가 등 종합 리포트]
```

### 연관 페이지 상세

#### **주간 리포트 (📄)**
- 모든 페이지의 데이터를 종합하여 리포트 생성
- 매출 데이터 (`sales`)
- 판매 데이터 (`daily_sales_items`)
- 재료 사용량 (계산)
- 원가 분석 (계산)

---

## 📋 데이터 테이블별 사용 페이지 정리

### `menu_master` (메뉴 마스터)
- **입력**: 메뉴 등록
- **사용**: 레시피 등록, 원가 파악, 판매 관리, 통합 대시보드, 주간 리포트

### `ingredient_master` (재료 마스터)
- **입력**: 재료 등록
- **사용**: 레시피 등록, 원가 파악, 재료 사용량 집계, 발주 관리

### `recipes` (레시피)
- **입력**: 레시피 등록
- **사용**: 원가 파악, 재료 사용량 집계, 판매 관리, 통합 대시보드

### `sales` (매출)
- **입력**: 매출 등록, 점장 마감
- **사용**: 매출 관리, 통합 대시보드, 실제정산, 주간 리포트

### `daily_sales_items` (일일 판매 내역)
- **입력**: 점장 마감, 판매량 등록
- **사용**: 재료 사용량 집계, 판매 관리, 목표 매출구조, 통합 대시보드, 주간 리포트

### `daily_close` (일일 마감)
- **입력**: 점장 마감
- **사용**: 통합 대시보드, 주간 리포트

### `expense_structure` (비용 구조)
- **입력**: 목표 비용구조
- **사용**: 목표 매출구조, 실제정산, 통합 대시보드

### `targets` (목표)
- **입력**: 목표 매출구조
- **사용**: 실제정산, 통합 대시보드

### `actual_settlement` (실제 정산)
- **입력**: 실제정산
- **사용**: 실제정산 (비교 분석)

### `inventory` (재고)
- **입력**: 발주 관리 (안전재고 등록, 현재고 수정)
- **사용**: 발주 관리 (발주 추천)

---

## 🔄 주요 숫자 연동 포인트 요약

1. **원가 계산**: 재료 단가 × 레시피 사용량 = 메뉴 원가
2. **재료 사용량**: 메뉴 판매수량 × 레시피 사용량 = 재료 사용량
3. **발주 계산**: 현재고 - 예상 사용량 < 안전재고 → 발주 필요
4. **손익분기점**: 고정비 ÷ (1 - 변동비율) = 손익분기점 매출
5. **목표 대비 달성률**: (실제 매출 ÷ 목표 매출) × 100
6. **공헌이익**: 매출 - 원가
7. **원가율**: (원가 ÷ 판매가) × 100

---

## 💡 사용 시나리오별 페이지 순서

### 시나리오 1: 초기 설정 (최초 1회)
1. 재료 등록
2. 메뉴 등록
3. 레시피 등록
4. 원가 파악 (확인)

### 시나리오 2: 일일 운영 (매일)
1. 점장 마감 (매출 + 판매량 입력)
2. 발주 관리 (재고 확인 및 발주)

### 시나리오 3: 주간 분석 (주 2-3회)
1. 매출 관리 (매출 확인)
2. 판매 관리 (메뉴별 성과)
3. 재료 사용량 집계 (재료 소비 확인)
4. 원가 파악 (원가율 확인)

### 시나리오 4: 월간 정산 (월 1-2회)
1. 목표 비용구조 (목표 설정)
2. 목표 매출구조 (목표 매출 설정)
3. 실제정산 (실제 vs 목표 비교)

### 시나리오 5: 발주 업무 (필요시)
1. 재료 사용량 집계 (사용량 확인)
2. 발주 관리 (발주 추천 및 발주)

---

## 🚨 마감보고 vs 매출 등록 vs 판매량 등록: 연동·충돌 정리

### 1. 각 페이지가 저장하는 데이터

| 저장 대상 | 마감보고 (점장 마감) | 매출 등록 | 판매량 등록 |
|----------|---------------------|----------|------------|
| **daily_close** | ✅ upsert (매출·방문자·특이사항·메모·sales_items) | ❌ 안 함 | ❌ 안 함 |
| **sales** | ✅ upsert (card/cash/total) | ✅ upsert (card/cash/total) | ❌ 안 함 |
| **naver_visitors** | ✅ upsert (visitors) | ✅ upsert (방문자 탭에서만) | ❌ 안 함 |
| **daily_sales_items** | ✅ **해당 날짜 전부 DELETE → INSERT** | ❌ 안 함 | ✅ **메뉴별 qty 누적** (있으면 +추가, 없으면 insert) |

- **마감보고**: `save_daily_close_transaction` RPC 호출 → `daily_close` + `sales` + `naver_visitors` + `daily_sales_items` 한 번에 처리.
- **매출 등록**: 매출 탭 → `save_sales` (sales만). 방문자 탭 → `save_visitor` (naver_visitors만). **daily_close, daily_sales_items는 건드리지 않음.**
- **판매량 등록**: `save_daily_sales_item` → `daily_sales_items`만. **기존 (날짜, 메뉴) 있으면 qty에 누적**, 없으면 새 행 추가.

---

### 2. 테이블별 연동 관계

```
                    마감보고                 매출 등록            판매량 등록
                         │                       │                    │
  daily_close            │ upsert                │ (미사용)            │ (미사용)
  (단일 소스)            └───────────────────────┴────────────────────┘
       │
       ├── sales        upsert (호환)         upsert                  —
       ├── naver_visitors  upsert (호환)      upsert (방문자 탭)       —
       └── daily_sales_items
                         DELETE+INSERT (해당일)  —                  누적(추가)
```

- **매출·방문자**: `sales`, `naver_visitors`는 마감보고와 매출 등록 **둘 다** 쓸 수 있어서, 같은 날짜면 **나중에 저장한 값**이 최종.
- **판매량**: 마감보고는 **해당 날짜 전체를 갈아엎고** `sales_items` 기준으로 다시 넣음. 판매량 등록은 **메뉴별로 누적**만 함.

---

### 3. 충돌 지점 요약

#### 3.1 매출 (sales) / daily_close

| 상황 | 결과 | 비고 |
|------|------|------|
| 마감보고만 사용 | ✅ daily_close = sales, 일치 | 정상 |
| 매출 등록만 사용 | ✅ sales만 갱신, daily_close 없음 | 매출 분석 등은 sales 기준으로 동작 |
| **마감보고 후 매출 등록** | ⚠️ **sales만 덮어씀, daily_close는 그대로** | **sales ≠ daily_close** 불일치 |
| 매출 등록 후 마감보고 | ✅ 마감보고가 sales 다시 upsert | 마감보고 값이 최종, 일치 |

- **매출 등록**은 `daily_close`를 **절대 수정하지 않음**.  
  → 마감보고로 넣은 "공식" 매출과, 매출 등록으로 나중에 수정한 `sales`가 **같은 날짜에 공존**하면 **숫자 불일치**.
- 앱에서는 `save_sales` 시 `daily_close` 존재 여부/값을 **충돌 감지용으로만** 쓰고, 경고 후 **sales는 그대로 덮어쓰기**함.

#### 3.2 방문자 (naver_visitors)

| 상황 | 결과 | 비고 |
|------|------|------|
| 마감보고만 / 매출 등록(방문자)만 | ✅ 각자 upsert, 일치 | 정상 |
| **같은 날짜에 둘 다 입력** | ⚠️ **나중에 저장한 쪽이 최종** | upsert라 덮어쓰기, 충돌 아닌 대체 |

- 논리적 "충돌"이라기보다 **저장 순서**에 따라 값이 바뀜.  
  → 같은 날 **마감보고**와 **매출 등록(방문자)** 를 둘 다 쓰면, **의도치 않게 나중 입력이 이전 입력을 덮어씀** 가능.

#### 3.3 판매량 (daily_sales_items) — **가장 큰 충돌**

| 상황 | 결과 | 비고 |
|------|------|------|
| 마감보고만 사용 | ✅ 해당일 `daily_sales_items` = 마감 입력분 | 정상 |
| 판매량 등록만 사용 | ✅ 메뉴별 누적만 반영 | 정상 |
| **마감보고 후 판매량 등록** | ✅ 마감 입력 + **추가분 누적** | "보완 입력" 용도로는 의도대로 동작 |
| **판매량 등록 후 마감보고** | 🚨 **해당 날짜 daily_sales_items 전부 DELETE 후 INSERT** | **판매량 등록분 전부 삭제**, 마감보고 입력분만 남음 |

- 마감보고 트랜잭션은 **해당 (store_id, date)의 `daily_sales_items`를 전부 지운 뒤**, `sales_items` JSONB만 넣음.  
  → **같은 날짜**에 **판매량 등록으로 먼저 넣어둔 데이터**가 있으면, **마감보고 저장 시 전부 삭제**되고, 마감보고에 입력한 메뉴/수량만 남음.
- **재료 사용량 집계·발주·판매 분석** 등은 모두 `daily_sales_items`를 쓰므로,  
  → "판매량 등록만 하고 마감은 안 했다"가 나중에 "마감만 했다"로 바뀌면, **이전 판매량 등록분이 사라져** 숫자가 틀어짐.

---

### 4. 권장 사용 흐름 (충돌 최소화)

1. **일일 매출·방문자·판매량을 한 번에 넣을 때**  
   → **마감보고(점장 마감)만** 사용.  
   - `daily_close` + `sales` + `naver_visitors` + `daily_sales_items`가 한 트랜잭션으로 맞게 저장됨.

2. **매출만 따로 수정·추가할 때**  
   - **해당 날짜에 마감보고를 이미 했다면**  
     → 매출 등록으로 `sales`를 바꿔도 `daily_close`는 안 바뀌어 **불일치** 발생.  
     → 가능하면 **마감보고에서 같은 날짜로 다시 저장**하는 쪽 권장.  
   - 아직 마감보고를 안 한 날이면  
     → 매출 등록만 써도 됨 (이후 마감보고 시 sales가 한 번 더 upsert됨).

3. **판매량만 추가·수정할 때**  
   - **해당 날짜 마감보고를 이미 했다**  
     → 판매량 등록으로 **누적**만 하면 됨. 마감보고 데이터는 유지되고, 추가분만 더해짐.  
   - **해당 날짜 마감보고를 아직 안 했다**  
     → 판매량 등록 먼저 한 뒤, **같은 날 마감보고를 하면**  
     → **방금 넣은 판매량이 전부 삭제**되므로,  
     → **반드시 "마감보고 먼저 → 부족분만 판매량 등록"** 순서 권장.

4. **방문자만 넣을 때**  
   - 마감보고 / 매출 등록(방문자) **둘 다** `naver_visitors`를 upsert하므로,  
     → **같은 날짜에 한쪽만** 쓰는 것이 안전.  
     → 이미 마감보고에 방문자까지 넣는 루틴이 있으면, **방문자만 따로 매출 등록에서 넣는 경우**를 줄이는 것이 좋음.

---

### 5. 숫자 연동 요약

- **매출**:  
  - `sales` ← 마감보고, 매출 등록  
  - `daily_close.total_sales` ← **마감보고만**  
  - 매출 등록이 나중이면 **sales ≠ daily_close** 가능.
- **방문자**:  
  - `naver_visitors` ← 마감보고, 매출 등록(방문자)  
  - **나중 저장 = 최종**.
- **판매량**:  
  - `daily_sales_items` ← 마감보고(해당일 **전체 교체**), 판매량 등록(**누적**)  
  - **판매량 등록 후 마감보고** 시, **등록분 삭제**로 이어지는 것이 핵심 충돌.
