# Streamlit 애니메이션 안정화 구조 진단 보고서

**작성일**: 2026-01-26  
**대상 앱**: Store Ops v1 (Streamlit + Supabase SaaS)  
**목적**: 애니메이션이 안정적으로 적용될 수 있는 구조 설계 및 안정화 프레임 구축

---

## 📋 요약 (핵심 결론)

### 현재 상태
- ✅ **CSS 계층 관리 구조 존재**: BASE/THEME/FX/DOM/RESCUE 5계층으로 분리
- ⚠️ **CSS 주입 중복 가능성**: rerun마다 재주입되는 DOM 계층 + 직접 주입 혼재
- ⚠️ **DOM 안정성 취약**: Streamlit rerun 시 DOM 재생성으로 애니메이션 리셋
- ⚠️ **JavaScript 의존성 높음**: MutationObserver, setInterval 등으로 DOM 변경 감지/재적용
- ⚠️ **iframe 격리 문제**: AgGrid iframe 내부 애니메이션 제어 어려움

### 핵심 문제점 TOP 10

1. **rerun 시 DOM 재생성으로 애니메이션 상태 초기화**
   - Streamlit은 rerun 시 전체 DOM을 재생성하므로 진행 중인 애니메이션이 리셋됨
   - `animation-play-state`나 `animation-delay` 조작이 어려움

2. **CSS 주입 타이밍 불일치**
   - BASE/THEME는 1회 주입, DOM은 rerun마다 주입
   - 페이지별 CSS가 서로 다른 시점에 주입되어 우선순위 충돌 가능

3. **직접 st.markdown CSS 주입 혼재**
   - `app.py`에서 `st.markdown("""<style>...""")` 직접 사용
   - `css_manager`를 거치지 않은 주입으로 추적/관리 어려움

4. **JavaScript 강제 재적용 패턴**
   - `fixMaterialIcons()` 함수가 setInterval(1000ms)로 주기적 실행
   - MutationObserver로 DOM 변경 감지 후 재적용
   - 애니메이션 중단/재시작 가능성

5. **key 속성 부재로 인한 DOM 불안정**
   - Streamlit 컴포넌트에 key가 없으면 rerun 시 재생성
   - 애니메이션이 적용된 요소가 새 DOM으로 교체되면 애니메이션 리셋

6. **iframe 내부 제어 한계**
   - AgGrid iframe 내부는 외부 CSS/JS 영향 받지 않음
   - iframe 내부 애니메이션은 별도 전략 필요

7. **전역 CSS 변수와 로컬 애니메이션 충돌**
   - `:root` CSS 변수는 안정적이나, 페이지별 애니메이션이 변수 덮어쓸 수 있음

8. **components.html 미활용**
   - 현재 구조에서 `st.components.html` 사용 패턴 없음
   - 격리된 애니메이션 영역 구축 기회 상실

9. **애니메이션 클래스 적용 타이밍 불확실**
   - CSS는 주입되지만, HTML 요소에 클래스가 적용되는 시점과 애니메이션 시작 시점 불일치

10. **성능 영향 가능성**
    - MutationObserver + setInterval 조합이 성능 저하 유발 가능
    - 애니메이션 중 DOM 조작 시 리플로우/리페인트 발생

---

## 🔍 현재 구조 진단

### 1. 페이지 렌더 흐름

```
app.py 실행
  ↓
bootstrap() 호출 (set_page_config)
  ↓
inject_global_ui() 호출 (BASE/THEME CSS 1회 주입)
  ↓
inject_sidebar_premium_css() 호출 (DOM CSS rerun마다 주입)
  ↓
st.markdown() 직접 CSS 주입 (app.py 내부)
  ↓
st.markdown() JavaScript 주입 (Material Icons 수정)
  ↓
사이드바 렌더링 (render_expanded_sidebar)
  ↓
페이지 라우팅 (if/elif 체인)
  ↓
페이지별 render_*() 함수 호출
  ↓
페이지 내부에서 추가 CSS/JS 주입 가능
  ↓
rerun 발생 시 위 과정 반복 (DOM 재생성)
```

**문제점**:
- CSS 주입 순서가 일관되지 않음
- 페이지별 CSS가 언제 주입되는지 불명확
- rerun 시 모든 CSS가 다시 주입되거나, 1회 주입 CSS는 유지되지만 DOM은 재생성

### 2. 전역 CSS/JS 주입 구조

#### CSS 계층 구조 (css_manager.py)

| 계층 | 주입 방식 | 주입 시점 | 예시 |
|------|----------|----------|------|
| BASE | `inject_base()` | 1회 (세션당) | CSS 변수, 폰트 |
| THEME | `inject_theme()` | 1회 (세션당) | 다크모드, 기본 스타일 |
| FX | `inject_fx()` | 1회 (세션당) | 애니메이션, glow 효과 |
| DOM | `inject_dom()` | rerun마다 | 사이드바, 폼 스타일 |
| RESCUE | `inject_rescue()` | 1회 (세션당) | 최종 안전핀 |

#### 현재 주입 위치

1. **app.py 최상단**:
   - `bootstrap()` → `set_page_config`
   - `inject_global_ui()` → BASE/THEME
   - `inject_sidebar_premium_css()` → DOM (사이드바)
   - `st.markdown()` 직접 주입 (Material Icons, 버튼 스타일 등)

2. **페이지별 함수 내부**:
   - `render_common_header()` → THEME (헤더 CSS)
   - 기타 페이지에서 `inject_*()` 호출 가능

**문제점**:
- `app.py`에서 `css_manager`를 거치지 않은 직접 주입 혼재
- 주입 순서가 코드 실행 순서에 의존
- rerun 시 DOM 계층은 재주입되지만 BASE/THEME는 유지 → 우선순위 충돌 가능

### 3. DOM 안정성

#### Streamlit의 DOM 재생성 특성

- **rerun 발생 시**: 전체 스크립트 재실행 → DOM 재생성
- **key 속성**: Streamlit 컴포넌트에 `key`가 있으면 동일 key로 재사용 시도
- **상태 유지**: `st.session_state`는 유지되지만 DOM은 새로 생성

#### 현재 key 사용 패턴

```python
# 사이드바 버튼
st.button(label, key=f"btn_{key}", ...)  # ✅ key 사용

# 페이지 라우팅
page = st.session_state.get("current_page", "홈")  # ✅ 상태 기반

# 하지만...
st.markdown('<div class="ps-header-card">...</div>', ...)  # ❌ key 없음
```

**문제점**:
- HTML 마크다운으로 직접 렌더링된 요소는 key가 없어 rerun 시 재생성
- 애니메이션이 적용된 요소가 재생성되면 애니메이션 리셋

#### iframe 격리

- AgGrid는 iframe 내부에서 렌더링
- 외부 CSS/JS가 iframe 내부에 영향을 주려면 `iframe.contentDocument` 접근 필요
- 현재 `theme_manager.py`에서 AgGrid 다크 테마를 위해 JavaScript로 강제 적용 중

**문제점**:
- iframe 내부 애니메이션은 외부 전략과 분리 필요
- iframe 로드 타이밍에 의존적 (setTimeout, setInterval 사용)

### 4. 세션/상태 변경이 UI에 미치는 영향

#### rerun 트리거

1. **버튼 클릭**: `st.button()` → `st.rerun()` 호출
2. **상태 변경**: `st.session_state` 직접 수정 후 `st.rerun()`
3. **위젯 상호작용**: `st.selectbox`, `st.number_input` 등 변경 시 자동 rerun

#### 애니메이션에 미치는 영향

- **진행 중인 애니메이션**: rerun 시 DOM 재생성으로 중단
- **CSS 애니메이션**: `@keyframes`는 CSS에 정의되어 있으므로 재생성 후에도 적용 가능
- **JavaScript 애니메이션**: `requestAnimationFrame` 등은 rerun 시 초기화

### 5. Streamlit 특성상 애니메이션이 깨지기 쉬운 구조

#### 취약 패턴

1. **DOM 재생성 의존 애니메이션**
   ```python
   # ❌ 나쁜 예: rerun 시 애니메이션 리셋
   st.markdown('<div class="animate-in">...</div>', ...)
   ```

2. **JavaScript 타이밍 의존**
   ```python
   # ❌ 나쁜 예: DOM 로드 후 실행 가정
   st.markdown("""
   <script>
   setTimeout(() => {
       element.classList.add('animate');
   }, 100);
   </script>
   """)
   ```

3. **상태 기반 조건부 애니메이션**
   ```python
   # ⚠️ 주의: 상태 변경 시 rerun으로 애니메이션 재시작
   if st.session_state.get("show_animation"):
       st.markdown('<div class="fade-in">...</div>')
   ```

#### 안정적인 패턴 (현재 사용 중)

1. **CSS-only 무한 애니메이션**
   ```css
   /* ✅ 좋은 예: CSS에 정의되어 rerun 후에도 유지 */
   @keyframes ps-gradientShift {
       0% { background-position: 0% 50%; }
       100% { background-position: 100% 50%; }
   }
   .ps-header-card {
       animation: ps-gradientShift 8s ease infinite;
   }
   ```

2. **CSS 변수 기반**
   ```css
   /* ✅ 좋은 예: CSS 변수는 안정적 */
   :root {
       --ps-accent: #39ff14;
   }
   ```

---

## 🎨 애니메이션 친화 구조 설계

### 전역 UI Wrapper 구조 (고정 Anchor 개념)

#### 목표
- rerun 후에도 DOM 구조가 일관되게 유지되도록 고정 anchor 요소 제공
- 애니메이션이 적용될 컨테이너를 안정적으로 식별

#### 설계안

```python
# src/ui/animation_wrapper.py (신규 생성)

def inject_animation_anchor():
    """애니메이션용 고정 anchor 주입 (1회)"""
    if st.session_state.get("_ps_animation_anchor_injected", False):
        return
    
    anchor_html = """
    <div id="ps-animation-root" data-ps-anchor="true" style="display: contents;">
        <!-- 모든 페이지 콘텐츠는 이 안에 렌더링 -->
    </div>
    """
    
    # BASE 계층에 주입
    from src.ui.css_manager import inject_base
    inject_base(f"<div id='ps-animation-root' data-ps-anchor='true' style='display: contents;'></div>", "animation_anchor")
    
    st.session_state["_ps_animation_anchor_injected"] = True


def wrap_page_content(content_func):
    """페이지 콘텐츠를 animation wrapper로 감싸기"""
    inject_animation_anchor()
    
    # 페이지 콘텐츠 렌더링
    with st.container():
        st.markdown('<div data-ps-page-wrapper="true">', unsafe_allow_html=True)
        content_func()
        st.markdown('</div>', unsafe_allow_html=True)
```

**사용 예시**:
```python
# app.py
from src.ui.animation_wrapper import wrap_page_content

if page == "홈":
    wrap_page_content(lambda: render_home())
```

### CSS 주입 1회화/보호 구조

#### 목표
- 모든 CSS를 `css_manager`를 통해서만 주입
- 주입 순서 명확화
- 중복 주입 방지

#### 개선안

```python
# src/ui/css_manager.py 개선

# 주입 순서 레지스트리
_INJECTION_ORDER = {
    "BASE": 1,
    "THEME": 2,
    "FX": 3,
    "DOM": 4,
    "RESCUE": 5,
}

def _validate_injection_order(layer: str):
    """주입 순서 검증"""
    current_order = _INJECTION_ORDER.get(layer, 999)
    last_order = st.session_state.get("_ps_last_css_order", 0)
    
    if current_order < last_order:
        logger.warning(f"CSS 주입 순서 위반: {layer} (순서: {current_order}) < 마지막 주입 ({last_order})")
    
    st.session_state["_ps_last_css_order"] = current_order


# app.py에서 직접 주입 금지
# 모든 CSS는 css_manager 함수를 통해 주입
```

#### 주입 위치 통일

```python
# app.py 개선안

# ❌ 기존: 직접 주입
st.markdown("""
<style>
    @keyframes fadeInUp { ... }
</style>
""", unsafe_allow_html=True)

# ✅ 개선: css_manager 사용
from src.ui.css_manager import inject_fx
inject_fx("""
<style>
    @keyframes fadeInUp { ... }
</style>
""", "fade_animations")
```

### 페이지 공통 레이아웃 패턴

#### 목표
- 모든 페이지가 동일한 wrapper 구조 사용
- 애니메이션이 적용될 영역을 일관되게 식별

#### 설계안

```python
# src/ui/layouts/page_layout.py (신규 생성)

def render_page_with_animation(page_title: str, content_func: Callable):
    """
    애니메이션 친화 페이지 레이아웃
    
    Args:
        page_title: 페이지 제목
        content_func: 페이지 콘텐츠 렌더링 함수
    """
    # 1. 페이지 wrapper 시작
    st.markdown('<div data-ps-page="true" class="ps-page-container">', unsafe_allow_html=True)
    
    # 2. 헤더 (공통)
    from src.ui.common_header import render_common_header
    render_common_header()
    
    # 3. 콘텐츠 영역 (애니메이션 적용 가능)
    st.markdown('<div data-ps-content="true" class="ps-content-area">', unsafe_allow_html=True)
    content_func()
    st.markdown('</div>', unsafe_allow_html=True)
    
    # 4. 페이지 wrapper 종료
    st.markdown('</div>', unsafe_allow_html=True)
```

**CSS 규칙**:
```css
/* 페이지 진입 애니메이션 */
[data-ps-page="true"] {
    animation: ps-page-enter 0.3s ease-out;
}

@keyframes ps-page-enter {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* 콘텐츠 영역 애니메이션 */
[data-ps-content="true"] > * {
    animation: ps-content-fade-in 0.4s ease-out;
    animation-fill-mode: both;
}

[data-ps-content="true"] > *:nth-child(1) { animation-delay: 0.05s; }
[data-ps-content="true"] > *:nth-child(2) { animation-delay: 0.10s; }
[data-ps-content="true"] > *:nth-child(3) { animation-delay: 0.15s; }
```

### DOM Selector 전략

#### 목표
- 안정적인 selector로 애니메이션 타겟 지정
- rerun 후에도 동일 요소 선택 보장

#### 규칙

1. **data-attribute 우선 사용**
   ```html
   <!-- ✅ 좋은 예 -->
   <div data-ps-animation="fade-in" data-ps-key="header-card">
   
   <!-- ❌ 나쁜 예: 클래스만 사용 (중복 가능) -->
   <div class="animate-fade">
   ```

2. **고유 key 조합**
   ```python
   # 페이지별 고유 key 생성
   page_key = st.session_state.get("current_page", "홈")
   element_key = f"ps-{page_key}-header"
   
   st.markdown(f'<div data-ps-key="{element_key}">...</div>', ...)
   ```

3. **CSS 선택자 우선순위**
   ```css
   /* ✅ 좋은 예: data-attribute + 클래스 */
   [data-ps-animation="fade-in"].ps-animated {
       animation: ps-fade-in 0.3s ease-out;
   }
   
   /* ⚠️ 주의: 클래스만 사용 시 중복 가능 */
   .ps-animated {
       animation: ps-fade-in 0.3s ease-out;
   }
   ```

### rerun에도 애니메이션이 깨지지 않는 패턴

#### 패턴 1: CSS-only 무한 애니메이션 (현재 사용 중, 권장)

```css
/* ✅ 안정적: CSS에 정의되어 rerun 후에도 유지 */
.ps-header-card {
    animation: ps-gradientShift 8s ease infinite;
}

@keyframes ps-gradientShift {
    0% { background-position: 0% 50%; }
    100% { background-position: 100% 50%; }
}
```

**장점**:
- rerun 후에도 자동 재시작
- JavaScript 의존성 없음
- 성능 우수

**단점**:
- 일회성 애니메이션 (진입 효과 등)에는 부적합
- 애니메이션 상태 제어 어려움

#### 패턴 2: CSS 변수 + 상태 기반 클래스

```python
# Python
animation_state = st.session_state.get("_animation_state", "idle")
st.markdown(f'<div class="ps-animated" data-state="{animation_state}">...</div>', ...)

# CSS
.ps-animated[data-state="entering"] {
    animation: ps-fade-in 0.3s ease-out forwards;
}

.ps-animated[data-state="idle"] {
    /* 애니메이션 없음 */
}
```

**장점**:
- 상태 제어 가능
- rerun 후에도 상태 유지 (session_state)

**단점**:
- 상태 관리 복잡도 증가
- rerun 시 애니메이션 재시작 (의도하지 않을 수 있음)

#### 패턴 3: components.html 기반 격리 (신규 제안)

```python
# Python
import streamlit.components.v1 as components

def render_animated_section(content_html: str):
    """격리된 애니메이션 영역"""
    components.html(
        f"""
        <div id="ps-animated-section">
            <style>
                @keyframes fadeIn {{
                    from {{ opacity: 0; }}
                    to {{ opacity: 1; }}
                }}
                #ps-animated-section {{
                    animation: fadeIn 0.3s ease-out;
                }}
            </style>
            {content_html}
        </div>
        """,
        height=400
    )
```

**장점**:
- 완전 격리 (외부 CSS/JS 영향 없음)
- rerun 시에도 내부 상태 유지 가능 (localStorage 등)

**단점**:
- Streamlit 컴포넌트와 상호작용 어려움
- 높이 제한 필요
- 성능 오버헤드

---

## 📊 애니메이션 적용 방식 비교

### A) Streamlit 친화 CSS-only 전략

#### 언제 쓰는가
- 무한 반복 애니메이션 (로딩, 배경 효과)
- hover/active 상태 전환
- CSS 변수 기반 동적 스타일

#### 구조 요건
- CSS는 BASE/THEME/FX 계층에 1회 주입
- HTML은 data-attribute로 마킹
- JavaScript 최소화

#### 장점
- ✅ rerun 후 자동 재시작
- ✅ 성능 우수 (GPU 가속)
- ✅ JavaScript 의존성 없음
- ✅ 브라우저 호환성 우수

#### 단점
- ❌ 일회성 애니메이션 제어 어려움
- ❌ 애니메이션 상태 동기화 불가
- ❌ 복잡한 시퀀스 애니메이션 제한

#### 금지 패턴
```css
/* ❌ 금지: JavaScript로 애니메이션 클래스 추가/제거 */
.element {
    /* 초기 상태 */
}
.element.animate {
    animation: fadeIn 0.3s;
}
```

### B) components.html 기반 분리 애니메이션 전략

#### 언제 쓰는가
- 복잡한 시퀀스 애니메이션
- 애니메이션 상태를 rerun 후에도 유지해야 할 때
- 외부 라이브러리 (GSAP, Framer Motion 등) 사용

#### 구조 요건
- `st.components.html`로 격리된 영역 생성
- 내부에서 완전한 HTML/CSS/JS 제어
- 외부와의 통신은 `components.html`의 `args`/`events` 사용

#### 장점
- ✅ 완전한 제어권
- ✅ rerun 후 상태 유지 가능 (localStorage)
- ✅ 외부 라이브러리 사용 가능
- ✅ 복잡한 애니메이션 구현 가능

#### 단점
- ❌ Streamlit 컴포넌트와 직접 상호작용 불가
- ❌ 높이 제한 필요
- ❌ 성능 오버헤드 (iframe)
- ❌ 개발 복잡도 증가

#### 금지 패턴
```python
# ❌ 금지: components.html 내부에서 Streamlit API 호출
components.html("""
<script>
    // Streamlit API는 components.html 내부에서 사용 불가
    Streamlit.setComponentValue(...);  // ❌
</script>
""")
```

---

## 🗺️ 단계별 안정화 로드맵

### Phase 0 — UI 구조/주입/렌더 안정화

#### 해야 할 코드 작업

1. **CSS 주입 통일**
   - [ ] `app.py`의 직접 `st.markdown()` CSS 주입을 `css_manager` 함수로 이동
   - [ ] 주입 순서 검증 로직 추가
   - [ ] 중복 주입 방지 강화

2. **애니메이션 Anchor 구축**
   - [ ] `src/ui/animation_wrapper.py` 생성
   - [ ] `inject_animation_anchor()` 구현
   - [ ] 모든 페이지를 `wrap_page_content()`로 감싸기

3. **페이지 레이아웃 통일**
   - [ ] `src/ui/layouts/page_layout.py` 생성
   - [ ] `render_page_with_animation()` 구현
   - [ ] 기존 페이지를 새 레이아웃으로 마이그레이션

4. **DOM Selector 규칙 정립**
   - [ ] data-attribute 네이밍 컨벤션 문서화
   - [ ] 기존 HTML에 data-attribute 추가
   - [ ] CSS 선택자를 data-attribute 기반으로 변경

#### 완료 기준
- ✅ 모든 CSS가 `css_manager`를 통해서만 주입됨
- ✅ 페이지별 레이아웃이 `render_page_with_animation()` 사용
- ✅ 모든 애니메이션 타겟이 data-attribute로 마킹됨
- ✅ 주입 순서 검증 통과

#### 절대 하면 안 되는 것
- ❌ `app.py`에서 직접 `st.markdown()` CSS 주입
- ❌ 클래스명만으로 애니메이션 타겟 지정
- ❌ JavaScript로 애니메이션 클래스 추가/제거 (rerun 시 리셋됨)

---

### Phase 1 — 애니메이션 테스트 존 구축

#### 해야 할 코드 작업

1. **테스트 페이지 생성**
   - [ ] `ui_pages/test/animation_test.py` 생성
   - [ ] CSS-only 애니메이션 샘플 구현
   - [ ] components.html 애니메이션 샘플 구현

2. **애니메이션 유틸리티 함수**
   - [ ] `src/ui/animation_utils.py` 생성
   - [ ] `apply_fade_in()`, `apply_slide_in()` 등 헬퍼 함수
   - [ ] 애니메이션 클래스 자동 적용 로직

3. **rerun 안정성 테스트**
   - [ ] 애니메이션 진행 중 rerun 발생 시나리오 테스트
   - [ ] 상태 기반 애니메이션 테스트
   - [ ] iframe 내부 애니메이션 테스트

#### 완료 기준
- ✅ 테스트 페이지에서 모든 애니메이션 패턴 검증 완료
- ✅ rerun 후에도 애니메이션이 정상 작동
- ✅ 애니메이션 유틸리티 함수 문서화 완료

#### 절대 하면 안 되는 것
- ❌ 테스트 코드를 프로덕션에 그대로 사용
- ❌ MutationObserver/setInterval 남용
- ❌ 애니메이션 중 DOM 직접 조작

---

### Phase 2 — 전역 적용 규칙화

#### 해야 할 코드 작업

1. **애니메이션 시스템 통합**
   - [ ] 공통 애니메이션 CSS를 FX 계층에 주입
   - [ ] 페이지 진입/퇴장 애니메이션 자동 적용
   - [ ] 버튼/카드 hover 애니메이션 통일

2. **성능 최적화**
   - [ ] `will-change` 속성 적절히 사용
   - [ ] GPU 가속 애니메이션 우선 사용
   - [ ] 불필요한 MutationObserver 제거

3. **접근성 고려**
   - [ ] `prefers-reduced-motion` 미디어 쿼리 지원
   - [ ] 애니메이션 토글 옵션 제공

#### 완료 기준
- ✅ 모든 페이지에 일관된 애니메이션 적용
- ✅ 성능 저하 없음 (Lighthouse 점수 유지)
- ✅ 접근성 요구사항 충족

#### 절대 하면 안 되는 것
- ❌ 모든 요소에 애니메이션 적용 (과도한 사용)
- ❌ `will-change` 남용 (메모리 사용 증가)
- ❌ 접근성 무시

---

### Phase 3 — UX 애니메이션 시스템화

#### 해야 할 코드 작업

1. **애니메이션 프리셋 라이브러리**
   - [ ] 자주 사용하는 애니메이션을 프리셋으로 제공
   - [ ] 페이지별 애니메이션 테마 설정
   - [ ] 사용자 설정으로 애니메이션 강도 조절

2. **애니메이션 디버깅 도구**
   - [ ] 개발 모드에서 애니메이션 상태 표시
   - [ ] 애니메이션 성능 모니터링
   - [ ] rerun 시 애니메이션 상태 로그

3. **문서화**
   - [ ] 애니메이션 가이드라인 문서
   - [ ] 컴포넌트별 애니메이션 예시
   - [ ] 트러블슈팅 가이드

#### 완료 기준
- ✅ 애니메이션 프리셋이 모든 페이지에서 사용 가능
- ✅ 개발자가 쉽게 애니메이션 추가 가능
- ✅ 문서화 완료

#### 절대 하면 안 되는 것
- ❌ 복잡한 애니메이션으로 인한 사용자 혼란
- ❌ 성능 저하를 무시한 화려한 효과
- ❌ 문서화 없이 코드만 작성

---

## ✅ 운영용 체크리스트

애니메이션을 추가할 때마다 다음 체크리스트를 통과해야 합니다.

### CSS 주입 위치

- [ ] **CSS는 `css_manager` 함수를 통해서만 주입**
  - `inject_base()`: CSS 변수, 폰트
  - `inject_theme()`: 테마 스타일
  - `inject_fx()`: 애니메이션, 효과
  - `inject_dom()`: DOM 종속 스타일 (rerun마다)
  - `inject_rescue()`: 최종 안전핀

- [ ] **직접 `st.markdown()` CSS 주입 금지**
  - 예외: 페이지별 일회성 스타일 (가능한 한 피함)

- [ ] **주입 순서 준수**
  - BASE → THEME → FX → DOM → RESCUE

### rerun 영향

- [ ] **애니메이션이 rerun 후에도 정상 작동하는가?**
  - CSS-only 무한 애니메이션: ✅ 자동 재시작
  - 일회성 애니메이션: ⚠️ rerun 시 재시작됨 (의도된 동작인지 확인)

- [ ] **JavaScript 애니메이션 사용 시**
  - rerun 후 자동 재시작 로직 필요
  - 또는 components.html로 격리

- [ ] **상태 기반 애니메이션**
  - `st.session_state`로 상태 관리
  - rerun 후 상태 유지 확인

### DOM 고정성

- [ ] **애니메이션 타겟에 data-attribute 사용**
  ```html
  <!-- ✅ 좋은 예 -->
  <div data-ps-animation="fade-in" data-ps-key="unique-id">
  
  <!-- ❌ 나쁜 예 -->
  <div class="animate-fade">
  ```

- [ ] **고유 key 보장**
  - 페이지별 고유 key 생성
  - 중복 key 방지

- [ ] **Streamlit 컴포넌트 key 사용**
  ```python
  st.button("클릭", key="unique-button-key")  # ✅
  ```

### key 규칙

- [ ] **모든 애니메이션 요소에 key 부여**
  - Streamlit 컴포넌트: `key` 파라미터
  - HTML 마크다운: `data-ps-key` attribute

- [ ] **key 네이밍 컨벤션 준수**
  - 형식: `ps-{page}-{element}-{id}`
  - 예: `ps-home-header-card`, `ps-sales-entry-form`

### 컴포넌트 격리 여부

- [ ] **components.html 사용 여부 결정**
  - 복잡한 애니메이션: components.html 고려
  - 간단한 애니메이션: CSS-only 권장

- [ ] **iframe 내부 애니메이션**
  - AgGrid 등 iframe 사용 시 별도 전략 필요
  - 외부에서 제어 어려움

### 성능 영향

- [ ] **GPU 가속 애니메이션 사용**
  ```css
  /* ✅ 좋은 예: transform, opacity */
  .element {
      transform: translateX(100px);
      opacity: 0.5;
  }
  
  /* ❌ 나쁜 예: layout 속성 */
  .element {
      left: 100px;  /* 리플로우 발생 */
  }
  ```

- [ ] **will-change 적절히 사용**
  ```css
  /* ✅ 애니메이션 예정 요소에만 */
  .will-animate {
      will-change: transform;
  }
  
  /* ❌ 모든 요소에 사용 금지 */
  ```

- [ ] **애니메이션 수 제한**
  - 동시에 실행되는 애니메이션 최소화
  - 불필요한 애니메이션 제거

- [ ] **성능 테스트**
  - Lighthouse 점수 확인
  - 느린 기기에서 테스트
  - 애니메이션 중 프레임 드롭 확인

### 접근성

- [ ] **prefers-reduced-motion 지원**
  ```css
  @media (prefers-reduced-motion: reduce) {
      * {
          animation: none !important;
          transition: none !important;
      }
  }
  ```

- [ ] **애니메이션 토글 옵션**
  - 사용자가 애니메이션 비활성화 가능
  - 설정은 `st.session_state`에 저장

### 디버깅

- [ ] **개발 모드에서 애니메이션 상태 표시**
  - 애니메이션 진행 중인 요소 하이라이트
  - rerun 시 애니메이션 상태 로그

- [ ] **에러 처리**
  - 애니메이션 실패 시 fallback 제공
  - 콘솔 에러 확인

---

## 📝 결론 및 권장사항

### 즉시 적용 가능한 개선사항

1. **CSS 주입 통일**: `app.py`의 직접 주입을 `css_manager`로 이동
2. **data-attribute 추가**: 모든 애니메이션 타겟에 `data-ps-*` 추가
3. **페이지 레이아웃 통일**: `render_page_with_animation()` 도입

### 단기 (Phase 0-1)

- UI 구조 안정화
- 애니메이션 테스트 존 구축
- 기본 애니메이션 패턴 검증

### 중기 (Phase 2)

- 전역 애니메이션 규칙 적용
- 성능 최적화
- 접근성 개선

### 장기 (Phase 3)

- 애니메이션 시스템 고도화
- 사용자 커스터마이징
- 문서화 완료

### 최종 목표

**"애니메이션이 반드시 안정적으로 적용될 수밖에 없는 구조"**

- ✅ CSS 주입이 체계적으로 관리됨
- ✅ DOM 구조가 일관되게 유지됨
- ✅ rerun 후에도 애니메이션이 정상 작동
- ✅ 성능 저하 없음
- ✅ 접근성 요구사항 충족
- ✅ 개발자가 쉽게 애니메이션 추가 가능

---

**다음 단계**: Phase 0부터 순차적으로 진행하며, 각 Phase 완료 시 검증 후 다음 Phase로 진행.
